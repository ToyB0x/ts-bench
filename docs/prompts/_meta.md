# TypeScriptプロジェクト最適化のためのメタプロンプト

## 本プロンプトの目的

TypeScriptプロジェクトにおける性能最適化手法を体系化し、AIを活用して効率的に実装可能なプロンプトとして構造化することで、開発生産性とコンパイル性能の向上を支援する。

## 背景

TypeScript開発における性能課題は開発体験に直接影響する：

### 主要な課題領域
- **IDE体験**: 型推論やインテリセンスの応答速度
- **ビルド性能**: TypeScriptコンパイル時間とメモリ使用量
- **開発効率**: Hot Reloadや型チェックの速度
- **CI/CD**: パイプラインでのビルド時間とリソース消費

これらは相互に関連し、`tsc`の実行性能が全体の開発体験を左右する。

## AI支援による継続的改善

### メタプロンプト自体の進化
- **AI共同進化**: DevinやClaude、ClineなどのAIは本メタプロンプトの改善機会を積極的に提案すること
- **技術追従**: TypeScript、ビルドツール、開発環境の最新動向を反映
- **実証ベース**: 実際の性能改善結果に基づく手法の評価更新

### 品質保証
- **検証可能性**: 各手法は`ts-bench`などのツールで測定可能であること
- **再現性**: AIが自動実装する際の具体的な手順を明示
- **安全性**: 本番環境への影響リスクを明確化

## 技術リソースと参考資料

### TypeScript公式ドキュメント
- **Performance Wiki**: https://github.com/microsoft/Typescript/wiki/Performance  
  コンパイル性能の基本原則とベストプラクティス
- **Performance Tracing**: https://github.com/microsoft/TypeScript/wiki/Performance-Tracing  
  `--generateTrace`を用いた詳細な性能分析手法
- **VS Code Language Service**: https://github.com/microsoft/TypeScript/wiki/Debugging-Language-Service-in-VS-Code  
  IDE統合における性能問題の診断
- **Issue #30235**: https://github.com/microsoft/TypeScript/issues/30235  
  大規模プロジェクトにおける性能課題の議論

### モノレポ・ビルドツール
- **Turborepo Compiled Packages**: https://turborepo.com/docs/core-concepts/internal-packages#compiled-packages  
  モノレポでの効率的なTypeScriptビルド戦略
- **TypeScript Project References**: https://turborepo.com/docs/guides/tools/typescript#you-likely-dont-need-typescript-project-references  
  プロジェクト参照の適切な使用判断
- **Turborepo Discussions**: 
  - https://github.com/vercel/turborepo/discussions/10325
  - https://github.com/vercel/turborepo/discussions/4143

### 測定・分析ツール
- **ts-bench**: https://github.com/ToyB0x/ts-bench (このリポジトリ)  
  TypeScript性能の継続的測定とベンチマーク
- **DeepWiki**: https://deepwiki.com/ToyB0x/ts-bench  
  プロジェクトの詳細な技術ドキュメント
- **@typescript/analyze-trace**: https://www.npmjs.com/package/@typescript/analyze-trace  
  TypeScriptトレースファイルの自動解析

### 実践的な改善事例
- **明示的型注釈**: https://zenn.dev/cybozu_frontend/articles/ts-explicit-type-annotation  
  型推論負荷軽減のための具体的手法
- **大規模プロジェクト最適化**: https://zenn.dev/forcia_tech/articles/20231017_tsuji  
  実際のプロダクションでの性能改善事例
- **TypeScript高速化**: https://qiita.com/knjname/items/fc83a4248f459f1b052e  
  コンパイル速度向上のテクニック集

## TypeScript最適化手法一覧

### 評価基準
各手法を以下の基準で評価し、AIによる自動実装の優先順位を決定する：

### 1. 設定最適化
| 手法 | 実装容易度 | 段階実装 | AI自動化 | 性能影響 | デグレリスク | 備考 |
|------|------------|----------|----------|----------|-------------|------|
| tsconfig.json調整 | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ | ⭐ | 基本的な設定変更 |
| isolatedDeclarations※2 | ⭐⭐ | ⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ | 明示的型注釈強制 |
| 型定義絞り込み | ⭐⭐ | ⭐⭐⭐ | ⭐⭐ | ⭐⭐ | ⭐ | @typesの最適化 |
| コンパイラオプション最適化 | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ | ⭐ | strict系設定の調整 |
| excludeパターン最適化 | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ | ⭐⭐ | ⭐ | 不要ファイルの除外 |

### 2. コード構造最適化
| 手法 | 実装容易度 | 段階実装 | AI自動化 | 性能影響 | デグレリスク | 備考 |
|------|------------|----------|----------|----------|-------------|------|
| 明示的型注釈 | ⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐ | 型推論負荷軽減 |
| 型展開防止※3 | ⭐⭐ | ⭐⭐ | ⭐⭐ | ⭐⭐⭐ | ⭐⭐ | 再帰型の制御 |
| Interface vs Union最適化 | ⭐⭐ | ⭐⭐ | ⭐⭐ | ⭐⭐ | ⭐⭐ | 設計パターン変更 |
| 型エイリアス最適化 | ⭐⭐ | ⭐⭐ | ⭐⭐ | ⭐⭐ | ⭐ | 複雑型の簡素化 |
| 生成コード事前コンパイル※4 | ⭐⭐ | ⭐⭐ | ⭐⭐ | ⭐⭐⭐ | ⭐ | 生成ファイル最適化 |
| Conditional Types削減 | ⭐ | ⭐ | ⭐ | ⭐⭐⭐ | ⭐⭐ | 高度な型操作の見直し |

### 3. プロジェクト構造最適化
| 手法 | 実装容易度 | 段階実装 | AI自動化 | 性能影響 | デグレリスク | 備考 |
|------|------------|----------|----------|----------|-------------|------|
| Project References | ⭐ | ⭐ | ⭐ | ⭐⭐⭐ | ⭐⭐ | 大規模向け |
| モノレポ最適化 | ⭐ | ⭐ | ⭐ | ⭐⭐⭐ | ⭐⭐⭐ | アーキテクチャ変更 |
| 内部パッケージdts生成 | ⭐⭐ | ⭐⭐ | ⭐⭐ | ⭐⭐⭐ | ⭐ | 型定義事前生成 |
| 依存グラフ最適化※1 | ⭐ | ⭐ | ⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | 重い依存の分離 |
| ファイル分割戦略 | ⭐⭐ | ⭐⭐ | ⭐ | ⭐⭐ | ⭐⭐ | モジュール分割 |
| 依存関係最適化 | ⭐ | ⭐ | ⭐ | ⭐⭐ | ⭐⭐ | import/export整理 |

#### 注釈
**※1 依存グラフ最適化**: モノレポ内で重い型処理を持つ親パッケージが複数のリーフパッケージに影響を与える問題を解決。具体的手法：
- **依存グラフ分析**: パッケージ間の依存関係と型チェック時間を可視化
- **重い依存の分離**: 型処理負荷の高いパッケージを独立化またはインターフェース層で抽象化
- **段階的依存削減**: 不要な transitive dependencies の除去
- **型境界の設計**: 軽量な型インターフェースによる依存関係の最小化

**※2 isolatedDeclarations**: TypeScript 5.5+の新機能。明示的型注釈を強制することで：
- **モジュール間型依存の除去**: 型推論による依存関係を断ち切り、並列処理を可能にする
- **宣言ファイル生成の高速化**: 型情報の事前確定により.d.ts生成が高速化
- **ライブラリ開発への適用**: パッケージのエクスポート型を明示化

**※3 型展開防止**: 複雑な再帰型による指数的な型計算を防止する手法：
- **型名の明示的指定**: `typeof`や具体的型名を使用して型推論を制限
- **再帰型の制御**: 深い型ネストを避けるための型設計パターン
- **計算量の制限**: 型レベル計算の複雑さを手動で制御

**※4 生成コード事前コンパイル**: 自動生成されるTypeScriptファイル（Zodスキーマ等）を事前に.js/.d.tsに変換：
- **型推論負荷の削減**: 生成コードの型計算をビルド時に完了
- **実行時性能の向上**: 静的ファイルによる型チェック時間短縮
- **実測効果**: 14秒→8秒のコンパイル時間短縮事例

**※5 --generateTrace分析**: TypeScriptコンパイラの詳細な性能分析：
- **トレースファイル生成**: `tsc --generateTrace`による詳細ログ作成
- **Chrome Tracing統合**: `chrome://tracing`での視覚的分析
- **ボトルネック特定**: 具体的な型チェック処理時間の特定

### 4. ビルド・ツール最適化
| 手法 | 実装容易度 | 段階実装 | AI自動化 | 性能影響 | デグレリスク | 備考 |
|------|------------|----------|----------|----------|-------------|------|
| インクリメンタルビルド | ⭐⭐ | ⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ | ⭐ | tsbuildinfo活用 |
| 並列型チェック | ⭐⭐ | ⭐⭐ | ⭐⭐ | ⭐⭐ | ⭐ | fork-ts-checker等 |
| キャッシュ戦略 | ⭐⭐ | ⭐⭐ | ⭐⭐ | ⭐⭐⭐ | ⭐ | Turborepo/Nx活用 |
| 型チェック分離 | ⭐⭐ | ⭐⭐ | ⭐⭐ | ⭐⭐ | ⭐ | transpileOnly活用 |

### 5. 性能分析・診断
| 手法 | 実装容易度 | 段階実装 | AI自動化 | 性能影響 | デグレリスク | 備考 |
|------|------------|----------|----------|----------|-------------|------|
| --generateTrace分析※5 | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ | ⭐ | 性能ボトルネック特定 |
| Chrome Tracing活用 | ⭐⭐ | ⭐⭐⭐ | ⭐ | ⭐⭐ | ⭐ | 詳細な性能分析 |
| @typescript/analyze-trace | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ | ⭐ | 自動分析ツール |

**凡例**: ⭐(低/簡単/安全) ⭐⭐(中) ⭐⭐⭐(高/複雑/影響大)

### 実装プロンプト生成方針
1. **段階的アプローチ**: 低リスクな設定変更から開始
2. **測定駆動**: 各変更前後でts-benchによる測定実施
3. **自動化優先**: AI実装容易度の高い手法を優先的に体系化
4. **安全性重視**: 本番影響を最小化する段階的実装パス提供
